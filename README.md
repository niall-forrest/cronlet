# cronlet

The simplest way to add scheduled tasks to a Node.js application. A typed, fluent API with file-based job discovery, built-in retries, and a local dev dashboard. Just write functions and say when they should run.

```ts
// jobs/weekly-digest.ts
import { schedule, weekly } from "cronlet"

export default schedule(weekly("fri", "09:00"), async (ctx) => {
  await sendWeeklyDigest()
})
```

## Quick Start

```bash
npm install cronlet cronlet-cli
npx cronlet init
npx cronlet dev
```

```
  Detected Next.js (App Router) + TypeScript

  + Created src/jobs/
  + Created src/jobs/health-check.ts
  + Created cronlet.config.ts

  Next steps:

    npx cronlet dev
```

`cronlet init` detects your framework, creates a jobs directory, drops in a working example, and generates a config file. Then `cronlet dev` starts the local scheduler with hot reload and a dashboard at `http://localhost:3141`.

## Schedule API

### Intervals

```ts
import { schedule, every } from "cronlet"

schedule(every("30s"), handler)   // every 30 seconds
schedule(every("15m"), handler)   // every 15 minutes
schedule(every("2h"), handler)    // every 2 hours
schedule(every("1d"), handler)    // every day
schedule(every("1w"), handler)    // every week
```

### Daily

```ts
import { schedule, daily } from "cronlet"

schedule(daily("09:00"), handler)              // daily at 9:00 AM
schedule(daily("09:00", "17:00"), handler)     // daily at 9 AM and 5 PM
schedule(daily("00:00"), handler)              // daily at midnight
```

### Weekly

```ts
import { schedule, weekly } from "cronlet"

schedule(weekly("fri", "09:00"), handler)                    // every Friday at 9 AM
schedule(weekly(["mon", "wed", "fri"], "09:00"), handler)    // MWF at 9 AM
```

### Monthly

```ts
import { schedule, monthly } from "cronlet"

schedule(monthly(1, "09:00"), handler)              // 1st of month at 9 AM
schedule(monthly(15, "12:00"), handler)             // 15th of month at noon
schedule(monthly("last-fri", "17:00"), handler)     // last Friday of month
```

### Raw Cron

```ts
import { schedule, cron } from "cronlet"

schedule(cron("0 9 * * 1-5"), handler)    // 9 AM on weekdays
```

### Timezones

```ts
schedule(
  daily("09:00").withTimezone("America/New_York"),
  handler
)
```

## Configuration

```ts
schedule(
  daily("09:00"),
  {
    name: "daily-report",
    retry: {
      attempts: 3,
      backoff: "exponential",
      initialDelay: "30s"
    },
    timeout: "5m",
    onSuccess: async (ctx) => {
      console.log("Report sent!")
    },
    onFailure: async (error, ctx) => {
      await alertOps(error)
    }
  },
  async (ctx) => {
    await generateAndSendReport()
  }
)
```

## Job Context

Every handler receives a context object:

```ts
interface JobContext {
  jobId: string        // unique job identifier
  jobName: string      // human-readable name
  runId: string        // unique run identifier
  scheduledAt: Date    // when this run was scheduled
  startedAt: Date      // when the handler started
  attempt: number      // current attempt (1-based)
  signal: AbortSignal  // for cancellation
}
```

## CLI Commands

```bash
cronlet init             # Initialize cronlet in your project
cronlet dev              # Start dev server with hot reload
cronlet list             # List all discovered jobs
cronlet run <job-id>     # Manually trigger a job
cronlet validate         # Validate all job configurations
cronlet deploy --platform vercel  # Generate Vercel Cron routes
```

## Deploy to Vercel

Cronlet generates everything Vercel needs — API routes and `vercel.json` cron config. You write jobs with the typed API, Cronlet handles the boilerplate.

### Generate Routes

```bash
npx cronlet deploy --platform vercel
```

```
  Generating Vercel deployment...

  Jobs discovered:
    ✓ weekly-digest          every friday at 9:00 AM
    ✓ cleanup-sessions       every 6 hours

  Routes:
    + app/api/cron/weekly-digest/route.ts (new)
    + app/api/cron/cleanup-sessions/route.ts (new)

  vercel.json:
    + /api/cron/weekly-digest → "0 9 * * 5"
    + /api/cron/cleanup-sessions → "0 */6 * * *"

  Next steps:
    1. Commit the generated files
    2. Push to deploy on Vercel
    3. Vercel will automatically call your routes on schedule
```

### What Gets Generated

**API Route** (App Router):
```ts
// app/api/cron/weekly-digest/route.ts
// Generated by cronlet — do not edit

import { verifyCronRequest, executeJob } from "cronlet/verify";
import job from "../../../../jobs/weekly-digest";

export const maxDuration = 60;

// Vercel Cron sends GET requests to trigger jobs
export async function GET(request: Request) {
  const verification = verifyCronRequest(request);
  if (!verification.ok) {
    return new Response(JSON.stringify({ error: verification.error }), { status: 401 });
  }

  const result = await executeJob(job);
  return new Response(JSON.stringify(result), {
    status: result.status === "success" ? 200 : 500,
  });
}
```

**vercel.json**:
```json
{
  "crons": [
    { "path": "/api/cron/weekly-digest", "schedule": "0 9 * * 5" },
    { "path": "/api/cron/cleanup-sessions", "schedule": "0 */6 * * *" }
  ]
}
```

### Options

```bash
cronlet deploy --platform vercel [options]

--prefix <path>   # Route prefix (default: /api/cron)
--dry-run         # Preview without writing files
--force           # Overwrite manually edited files
--no-clean        # Keep orphaned routes from deleted jobs
```

### Configuration

Optional `cronlet.config.ts` for customization:

```ts
import { defineConfig } from "cronlet";

export default defineConfig({
  jobsDir: "./jobs",
  deploy: {
    prefix: "/api/cron",
    vercel: {
      maxDuration: 60,
    },
  },
});
```

### Limitations

- Vercel Cron minimum interval is 1 minute (no `every("30s")`)
- Vercel Cron runs in UTC — `.withTimezone()` is for local dev only
- Retry/timeout config runs within the serverless function execution time

## Deploy as a Worker

For any platform that runs Node — Railway, Fly.io, Docker, EC2 — use `createWorker()` to run cronlet as a standalone long-running process.

### Basic

```ts
// worker.ts
import { createWorker } from "cronlet"

const worker = createWorker({ dir: "./jobs" })
await worker.start()
```

```bash
npx tsx worker.ts
```

The worker discovers your jobs, schedules them, logs execution, exposes a health check on port 3141, and handles `SIGTERM`/`SIGINT` with graceful shutdown.

### With Options

```ts
import { createWorker } from "cronlet"

const worker = createWorker({
  dir: "./jobs",

  healthCheck: {
    enabled: true,
    port: 8080,
    path: "/healthz",
  },

  shutdownTimeout: 30_000,

  onJobComplete: (jobId, result) => {
    metrics.increment("cronlet.job.complete", { jobId, status: result.status })
  },
  onJobError: (jobId, error) => {
    Sentry.captureException(error, { tags: { jobId } })
  },
})

await worker.start()
```

### Worker API

```ts
await worker.start()                  // discover jobs, start scheduling
await worker.stop()                   // graceful shutdown
worker.getJobs()                      // list all registered jobs
await worker.trigger("sync-stripe")   // manually run a job by ID
worker.isRunning()                    // check if worker is active
```

### Health Check

The worker exposes a health endpoint for platforms that need one (Railway, Fly, Kubernetes):

```
GET /health → 200 { "status": "ok", "jobs": 3, "uptime": 12345 }
```

Port defaults to the `PORT` environment variable (standard for Railway/Fly) or `3141`. Disable with `healthCheck: { enabled: false }`.

### Graceful Shutdown

The worker handles `SIGTERM` and `SIGINT` automatically:

1. Stops accepting new scheduled runs
2. Waits for in-flight jobs to finish (configurable timeout, default 30s)
3. Closes the health check server
4. Exits cleanly

### Docker

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && pnpm install --frozen-lockfile
COPY . .
RUN pnpm build
CMD ["node", "dist/worker.js"]
```

### Railway / Fly

```json
{
  "scripts": {
    "worker": "tsx worker.ts"
  }
}
```

Set the start command to `npm run worker`. The health check will bind to the `PORT` env var automatically.

## Comparison

| Feature | Cronlet | Vercel Cron | Trigger.dev | Inngest |
|---------|---------|-------------|-------------|---------|
| Setup complexity | `cronlet init` | vercel.json | Dashboard + SDK | Dashboard + SDK |
| Type safety | Full TypeScript | None | Partial | Partial |
| Local development | Built-in dashboard | None | Requires tunnel | Requires tunnel |
| Deploy targets | Vercel, Railway, Fly, Docker, any Node host | Vercel only | Cloud only | Cloud only |
| Schedule syntax | Typed builders | Cron strings | Cron strings | Cron strings |
| Retries | Built-in | Manual | Built-in | Built-in |
| Graceful shutdown | Built-in | N/A | Managed | Managed |
| Pricing | Free (runs on your infra) | Hobby limits | Per-execution | Per-execution |

## Why Cronlet?

Sits between basic cron and full orchestration platforms:

- **Better DX than Vercel Cron** — typed schedules, retries, timeouts, local dev dashboard
- **Deploys anywhere** — Vercel Cron bridge, or a standalone worker on Railway, Fly, Docker, EC2
- **Simpler than Trigger.dev/Inngest** — no cloud dashboard, no webhooks, runs on your existing infrastructure

## Project Structure

```
your-app/
├── jobs/
│   ├── daily-report.ts
│   ├── cleanup-sessions.ts
│   └── billing/
│       └── sync-stripe.ts
├── package.json
└── ...
```

Jobs are discovered automatically from `./jobs`, `./src/jobs`, or `./app/jobs`.

## Development

This is a monorepo using pnpm workspaces and Turborepo.

### Structure

```
cronlet/
├── packages/
│   ├── cronlet/          # Core library (zero dependencies)
│   └── cronlet-cli/      # CLI tool
├── apps/
│   ├── dashboard/        # Local dev dashboard (Vite + React)
│   └── docs/             # Documentation site
└── examples/             # Example job files
```

### Setup

```bash
# Install dependencies
pnpm install

# Build all packages
pnpm build

# Run tests
pnpm test

# Link CLI globally for local development
cd packages/cronlet-cli && pnpm link --global

# Run with examples
cronlet dev --dir ./examples
```

### Key Packages

- **cronlet** - Core library with schedule builders, execution engine, and `createWorker()`.
- **cronlet-cli** - CLI with `init`, dev server, job discovery, and Vercel deploy.


## License

MIT
