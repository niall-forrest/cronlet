import { existsSync, readFileSync, writeFileSync, mkdirSync, rmSync, readdirSync } from "node:fs";
import { join, relative, dirname } from "node:path";
import type { JobDefinition } from "cronlet";
import type { ProjectInfo, CronletConfig } from "../detection.js";
import { validateForVercel, flattenJobId } from "../validation.js";
import { generateAppRoute } from "../generators/route-app.js";
import { generatePagesRoute } from "../generators/route-pages.js";
import {
  generateCronEntries,
  mergeVercelConfig,
  getRemovedCrons,
  getAddedCrons,
  getUpdatedCrons,
  type VercelConfig,
} from "../generators/vercel-json.js";

const GENERATED_HEADER = "// Generated by cronlet — do not edit";

export interface DeployOptions {
  /** Route prefix (default: /api/cron) */
  prefix: string;
  /** Force overwrite all files */
  force: boolean;
  /** Clean orphaned routes */
  clean: boolean;
  /** Dry run (don't write files) */
  dryRun: boolean;
  /** Max function duration in seconds */
  maxDuration?: number;
}

export interface DeployResult {
  /** Routes that were generated */
  generatedRoutes: Array<{ path: string; status: "new" | "updated" | "skipped" }>;
  /** Routes that were removed */
  removedRoutes: string[];
  /** Cron entries added to vercel.json */
  addedCrons: Array<{ path: string; schedule: string }>;
  /** Cron entries removed from vercel.json */
  removedCrons: Array<{ path: string; schedule: string }>;
  /** Cron entries with updated schedules */
  updatedCrons: Array<{ path: string; schedule: string }>;
  /** Validation warnings */
  warnings: string[];
  /** Validation errors (if any jobs were skipped) */
  errors: string[];
}

/**
 * Check if a file was generated by cronlet and hasn't been modified
 */
function isGeneratedFile(filePath: string): "generated" | "modified" | "not-generated" {
  if (!existsSync(filePath)) {
    return "not-generated";
  }

  const content = readFileSync(filePath, "utf-8");
  const firstLine = content.split("\n")[0];

  if (firstLine === GENERATED_HEADER) {
    return "generated";
  }

  return "modified";
}

/**
 * Get relative import path from route file to job file
 */
function getImportPath(
  routePath: string,
  jobPath: string
): string {
  const routeDir = dirname(routePath);
  // Remove extension from job path
  const jobPathWithoutExt = jobPath.replace(/\.(ts|js|mjs)$/, "");
  const relativePath = relative(routeDir, jobPathWithoutExt);

  // Ensure it starts with ./ or ../
  if (!relativePath.startsWith(".")) {
    return `./${relativePath}`;
  }
  return relativePath;
}

/**
 * Get the route file path for a job
 */
function getRoutePath(
  job: JobDefinition,
  project: ProjectInfo,
  prefix: string
): string {
  const flatId = flattenJobId(job.id);
  const prefixPath = prefix.replace(/^\//, ""); // Remove leading slash
  const ext = project.typescript ? ".ts" : ".js";

  if (project.router === "app") {
    return join(project.apiDir, prefixPath.replace("api/", ""), flatId, `route${ext}`);
  } else {
    return join(project.apiDir, prefixPath.replace("api/", ""), `${flatId}${ext}`);
  }
}

/**
 * Find all cronlet-generated routes in the output directory
 */
function findGeneratedRoutes(apiDir: string, prefix: string): string[] {
  const prefixPath = prefix.replace(/^\/api\//, "");
  const routesDir = join(apiDir, prefixPath);

  if (!existsSync(routesDir)) {
    return [];
  }

  const routes: string[] = [];

  function scanDir(dir: string) {
    const entries = readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(dir, entry.name);

      if (entry.isDirectory()) {
        scanDir(fullPath);
      } else if (entry.isFile() && /\.(ts|js)$/.test(entry.name)) {
        if (isGeneratedFile(fullPath) === "generated") {
          routes.push(fullPath);
        }
      }
    }
  }

  scanDir(routesDir);
  return routes;
}

/**
 * Deploy jobs to Vercel
 */
export async function deployToVercel(
  jobs: JobDefinition[],
  project: ProjectInfo,
  _jobsDir: string,
  options: DeployOptions,
  config: CronletConfig | null
): Promise<DeployResult> {
  const result: DeployResult = {
    generatedRoutes: [],
    removedRoutes: [],
    addedCrons: [],
    removedCrons: [],
    updatedCrons: [],
    warnings: [],
    errors: [],
  };

  const prefix = options.prefix;
  const maxDuration = options.maxDuration ?? config?.deploy?.vercel?.maxDuration ?? 60;

  // Validate all jobs
  const validJobs: JobDefinition[] = [];

  for (const job of jobs) {
    const validation = validateForVercel(job, maxDuration * 1000);

    if (!validation.valid) {
      result.errors.push(validation.error!);
      continue;
    }

    result.warnings.push(...validation.warnings);
    validJobs.push(job);
  }

  // Generate route files
  for (const job of validJobs) {
    const routePath = getRoutePath(job, project, prefix);
    const importPath = getImportPath(routePath, job.filePath!);

    // Check if file exists and if we should overwrite
    const fileStatus = isGeneratedFile(routePath);

    if (fileStatus === "modified" && !options.force) {
      result.generatedRoutes.push({ path: routePath, status: "skipped" });
      result.warnings.push(
        `Skipped ${routePath} — file was manually edited. Use --force to overwrite.`
      );
      continue;
    }

    // Generate the route content
    const routeContent =
      project.router === "app"
        ? generateAppRoute(job, {
            importPath,
            typescript: project.typescript,
            maxDuration,
          })
        : generatePagesRoute(job, {
            importPath,
            typescript: project.typescript,
            maxDuration,
          });

    // Write the file (unless dry run)
    if (!options.dryRun) {
      mkdirSync(dirname(routePath), { recursive: true });
      writeFileSync(routePath, routeContent);
    }

    result.generatedRoutes.push({
      path: routePath,
      status: fileStatus === "not-generated" ? "new" : "updated",
    });
  }

  // Clean orphaned routes
  if (options.clean && !options.dryRun) {
    const existingRoutes = findGeneratedRoutes(project.apiDir, prefix);
    const validRoutePaths = new Set(
      validJobs.map((job) => getRoutePath(job, project, prefix))
    );

    for (const routePath of existingRoutes) {
      if (!validRoutePaths.has(routePath)) {
        rmSync(routePath);

        // Also remove empty parent directories
        let dir = dirname(routePath);
        while (dir !== project.apiDir) {
          try {
            const entries = readdirSync(dir);
            if (entries.length === 0) {
              rmSync(dir, { recursive: true });
              dir = dirname(dir);
            } else {
              break;
            }
          } catch {
            break;
          }
        }

        result.removedRoutes.push(routePath);
      }
    }
  }

  // Update vercel.json
  const vercelJsonPath = join(project.rootDir, "vercel.json");
  let existingConfig: VercelConfig | null = null;

  if (existsSync(vercelJsonPath)) {
    try {
      existingConfig = JSON.parse(readFileSync(vercelJsonPath, "utf-8"));
    } catch {
      result.warnings.push("Failed to parse existing vercel.json");
    }
  }

  const cronEntries = generateCronEntries(validJobs, prefix);

  // Calculate diff for reporting
  result.addedCrons = getAddedCrons(existingConfig, cronEntries, prefix);
  result.removedCrons = getRemovedCrons(existingConfig, cronEntries, prefix);
  result.updatedCrons = getUpdatedCrons(existingConfig, cronEntries);

  // Merge and write
  const newConfig = mergeVercelConfig(existingConfig, cronEntries, prefix);

  if (!options.dryRun) {
    writeFileSync(vercelJsonPath, JSON.stringify(newConfig, null, 2) + "\n");
  }

  return result;
}
